# 소켓프로그래밍 16장

## 파일 디스크립터의 복사와 Half-close

읽기모드 File 포인터, 쓰기모드 File 포인터가 File Descriptor에 연결되어 있고, 파일 디스크립터는 소켓에 연결되어 있다면, 읽기모드와 쓰기모드 포인터 중 하나라도 소멸하면 파일 디스크립터가 소멸되고, 소켓이 소멸된다. (파일 디스크립터와 소켓 사이에는 "모든 파일 디스크립터가 삭제되어야 소켓이 소멸된다는 관계가 있다")

그러면 Half-close가 불가능하다.

이를 위해서 쓰기모드 포인터가 소멸되어 가리키고 있는 파일 디스크립터가 소멸해도, 읽기모드 포인터가 가리키고 있는 파일 디스크립터는 소멸하지 않아야 하는데 이를 위해서 읽기모드 File 포인터가 가리키고 있는 원본 파일 디스크립터를 복사하여 쓰기모드 File 포인터가 복사한 파일 디스크립터를 가리키게 하여 쓰기모드 포인터가 소멸해도 복사한 파일 디스크립터가 삭제되어 원본 파일디스크립터가 살아있으므로 소켓이 종료되지 않도록 할 수 있다.

## 파일 디스크립터의 복사

- 파일 디스크립터의 복사는 fork 함수호출 시 진행되는 복사와 차이 있음.
- 위 같은 복사는 프로세스를 통째로 복사하기 때문에 하나의 프로세스에 원본, 복사본 모두 존재하지 않음.
- 한 프로세스 내에서 파일 디스크립터가 두 개 존재하므로 구분하기 위해서는 둘 사이에 차이점이 있어야 함. -> 동일한 파일 또는 소켓의 접근을 위한 또 다른 파일 디스크립터를 생성 (파일 디스크립터의 정수 값이 다름)



# 소켓프로그래밍 17장

## epoll의 이해와 활용

select기반의 IO 멀티플렉싱이 느리다 -> epoll 사용

느린 이유)

1. select 함수호출 이후에 항상 모든 파일 디스크립터를 대상으로 하는 반복문
2. select 함수를 호출할 때마다 인자로 매번 전달해야 하는 관찰대상에 대한 정보들

select함수는 소켓의 변화를 관찰하는 함수로, 절대적으로 운영체제에 의해 완성되는 함수임. 그럼 어떻게 단점을 해결하나 -> 운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고, 관찰대상 범위, 또는 내용 변경이 있을 때 변경 사항만 알려주도록 한다. 

단, 운영체제가 이러한 방식을 지원해야만 사용 가능. 운영체제 별로 지원여부, 지원방식에 차이있음 (리눅스에서 epoll, 윈도우에서는 IOCP라 함)

개선된 IO 멀티플렉싱 모델은 운영체제 별로 호환되지 않는다. epoll방식은 리눅스에서만 지원되는 방식이므로, 대부분의 운영체제에서 지원되는 select도 중요하다. 

서버의 접속자 수가 많지 않고, 다양한 운영체제에서 운영이 가능해야 한다면 select 함수를 사용하는 것도 나쁘지 않다.



epoll의 장점)  = select함수의 단점과 상반됨

1. 상태변화의 확인을 위한 전체 파일 디스크립터를 대상으로 하는 반복문이 필요없음
2. 관찰대상의 정보를 매번 전달할 필요없음

