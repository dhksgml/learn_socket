# 소켓프로그래밍 16장

## 파일 디스크립터의 복사와 Half-close

읽기모드 File 포인터, 쓰기모드 File 포인터가 File Descriptor에 연결되어 있고, 파일 디스크립터는 소켓에 연결되어 있다면, 읽기모드와 쓰기모드 포인터 중 하나라도 소멸하면 파일 디스크립터가 소멸되고, 소켓이 소멸된다. (파일 디스크립터와 소켓 사이에는 "모든 파일 디스크립터가 삭제되어야 소켓이 소멸된다는 관계가 있다")

그러면 Half-close가 불가능하다.

이를 위해서 쓰기모드 포인터가 소멸되어 가리키고 있는 파일 디스크립터가 소멸해도, 읽기모드 포인터가 가리키고 있는 파일 디스크립터는 소멸하지 않아야 하는데 이를 위해서 읽기모드 File 포인터가 가리키고 있는 원본 파일 디스크립터를 복사하여 쓰기모드 File 포인터가 복사한 파일 디스크립터를 가리키게 하여 쓰기모드 포인터가 소멸해도 복사한 파일 디스크립터가 삭제되어 원본 파일디스크립터가 살아있으므로 소켓이 종료되지 않도록 할 수 있다.

## 파일 디스크립터의 복사

- 파일 디스크립터의 복사는 fork 함수호출 시 진행되는 복사와 차이 있음.
- 위 같은 복사는 프로세스를 통째로 복사하기 때문에 하나의 프로세스에 원본, 복사본 모두 존재하지 않음.
- 한 프로세스 내에서 파일 디스크립터가 두 개 존재하므로 구분하기 위해서는 둘 사이에 차이점이 있어야 함. -> 동일한 파일 또는 소켓의 접근을 위한 또 다른 파일 디스크립터를 생성 (파일 디스크립터의 정수 값이 다름)



# 소켓프로그래밍 17장

## epoll의 이해와 활용

select기반의 IO 멀티플렉싱이 느리다 -> epoll 사용

느린 이유)

1. select 함수호출 이후에 항상 모든 파일 디스크립터를 대상으로 하는 반복문
2. select 함수를 호출할 때마다 인자로 매번 전달해야 하는 관찰대상에 대한 정보들

select함수는 소켓의 변화를 관찰하는 함수로, 절대적으로 운영체제에 의해 완성되는 함수임. 그럼 어떻게 단점을 해결하나 -> 운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고, 관찰대상 범위, 또는 내용 변경이 있을 때 변경 사항만 알려주도록 한다. 

단, 운영체제가 이러한 방식을 지원해야만 사용 가능. 운영체제 별로 지원여부, 지원방식에 차이있음 (리눅스에서 epoll, 윈도우에서는 IOCP라 함)

개선된 IO 멀티플렉싱 모델은 운영체제 별로 호환되지 않는다. epoll방식은 리눅스에서만 지원되는 방식이므로, 대부분의 운영체제에서 지원되는 select도 중요하다. 

서버의 접속자 수가 많지 않고, 다양한 운영체제에서 운영이 가능해야 한다면 select 함수를 사용하는 것도 나쁘지 않다.



epoll의 장점)  = select함수의 단점과 상반됨

1. 상태변화의 확인을 위한 전체 파일 디스크립터를 대상으로 하는 반복문이 필요없음
2. 관찰대상의 정보를 매번 전달할 필요없음




## 레벨 트리거와 엣지 트리거

레벨트리거 : 입력버퍼에 데이터가 남아있는 동안 이벤트가 계속 등록됨

엣지트리거 : 입력버퍼에 데이터가 남아있다고 해서 이벤트를 추가로 등록하지 않음



엣지 트리거 구현에 있어서 필요한 내용 - 에러원인 확인

- 변수 errno을 이용한 오류의 원인을 확인하는 방법
- 넌-블로킹 IO를 위한 소켓의 특성을 변경하는 방법

레벨 트리거에 비해 엣지 트리거가 갖는 장점 = **데이터 수신과 데이터 처리되는 시점을 분리할 수 있음**



# 소켓프로그래밍 18장 - 멀티쓰레드 기반의 서버 구현

## 쓰레드의 등장 배경

멀티프로세스 기반의 단점)

1. 프로세스 생성이라는 부담스러운 작업과정을 운영체제에게 시킴
2. 두 프로세스 사이에서의 데이터 교환을 위해서는 별도의 IPC(프로세스 간 통신) 기법을 적용해야 함
3. 컨텍스트 스위칭에 따른 부담

쓰레드 -> 멀티프로세스의 특징을 유지하면서 단점을 극복, 일종의 ''경량화 된 프로세스''



둘 이상의 실행흐름을 갖기 위해서 프로세스가 유지하고 있는 메모리 영역을 통째로 복사한다는 것은 부담스럽다 --> 그러면 스택 영역만 분리하면 어떨까?

메모리 구조 - 데이터, 힙, 스택



스택 영역 분리로 인해 얻는 장점)

- 컨텍스트 스위칭 시 스택 영역만 조작
- 데이터 영역과 힙을 이용해서 데이터를 교환 가능

따라서 스택영역만 독립적이며, 데이터 영역과 힙 영역을 공유한다.



프로세스 : 운영체제 관점에서 별도의 실행흐름을 구성하는 단위

쓰레드 : 프로세스 관점에서 별도의 실행흐름을 구성하는 단위



POSIX (Portable Operating System Interface for Computer Environment) : UNIX 계열 운영체제간에 이식성을 높이기 위한 표준 API



임계영역 : 둘 이상의 쓰레드가 동시에 실행하면 문제를 일으키는 코드블록

- 쓰레드에 안전한 함수 -> 임계영역 있을 수 있으나 적절한 조치 덕분에 문제 안 일어나는 경우
- 쓰레드에 불안전한 함수



### 워커 쓰레드 모델

쓰레드의 문제점과 임계영역

"같은 메모리 공간에 둘 이상의 쓰레드가 동시에 접근함"

동기화 : 하나의 쓰레드가 변수에 접근하여 연산을 완료할 때 까지 다른 쓰레드가 변수에 접근하지 못하도록 함.



동기화가 필요한 상황)

- 동일한 메모리 영역으로의 동시접근이 발생하는 상황
- 동일한 메모리 영역에 접근하는 쓰레드의 실행순서를 지정해야 하는 상황 - 실행순서 컨트롤

### 뮤텍스

쓰레드 동시접근 허용 안 함



예시) 공용 화장실

들어갈 때 문을 잠그고, 일을 다 처리했으면 문을 열고 나온다.

누군가 화장실을 사용하는 중에는 다른 사람이 화장실을 사용할 수 없음



어? 그러면 누군가 화장실에 들어가서 나오지 않으면 어떻게 되나요?

-> 이런 상황을 데드락 상태라고 함.



### 세마포어

뮤텍스와 유사함.

0과 1만 사용하는 "바이너리 세마포어"로 쓰레드의  실행 순서 컨트롤을 설명

세마포어 값이 존재

이 값을 감소시키거나 증가시킴으로써 임계영역의 시작과 끝을 알림



## 쓰레드 소멸

리눅스의 쓰레드는 처음 호출하는, 쓰레드의 main 함수를 반환한다고 해서 쓰레드가 자동으로 소멸되지 않음

- pthread_join 함수 호출
- pthreda_detach 함수 호출

pthread_join은 쓰레드의 종료를 대기하며 쓰레드의 소멸을 유도한다.

단점으로 쓰레드가 종료될 때까지 블로킹 상태에 놓이게 된다.

pthread_detach를 호출해서 쓰레드에게 할당된 메모리의 소멸을 유도할 수 있다.

함수가 호출된 이후, 해당 쓰레드를 대상으로 pthread_join함수의 호출이 불가능하다.



# 소켓프로그래밍 19장 - windows에서의 쓰레드 사용

### 커널 오브젝트

윈도우 운영체제가 생성해서 관리하는 리소스들이다.

리소스의 종류에 따라서 관리의 방식이 다름. 예를 들어 파일이라면 파일과 관련된 데이터의 입출력 위치, 파일의 오픈 모드 등이 등록 및 갱신되어야 하고, 쓰레드라면 쓰레드 ID, 쓰레드가 속한 프로세스의 정보가 등록 및 유지되어야 한다. 이렇게 운영체제에 의해서 생성되는 리소스들은 관리를 목적으로 정보를 기록하기 위해 내부적으로 데이터 블록을 생성하는데, 이런 데이터 블록을 '커널 오브젝트'라고 함.

프로세스, 쓰레드, 쓰레드의 동기화에 사용되는 세마포어를 생성하더라도 각각 관리를 위한 커널 오브젝트들이 생성된다.



*커널 오브젝트의 소유자는 운영체제이다.



main 함수의 호출하는 주체는 누구일까? -> 쓰레드. 과거에는 프로세스가 정답인 경우도 있었음(특히 유닉스 계열 운영체제에서)

단일 쓰레드 모델의 프로그램 : 쓰레드를 별도로 생성하지 않음

멀티 쓰레드 모델의 프로그램 : 쓰레드를 별도로 생성함



커널 오브젝트를 구분하는 역할을 하는 정수로 표현되는 것 : 핸들

이 핸들은 리눅스의 파일 디스크립터에 비유된다.



윈도우의 쓰레드 소멸 시점은 쓰레드에 의해 처음 호출된, 쓰레드의 main 함수가 반환하는 시점임.



핸들 != 쓰레드 ID

핸들의 정수 값은 프로세스가 달라지면 중복될 수 있으나, 쓰레드 ID는 프로세스 영역을 넘어서서 중복되지 않음.



### 커널 오브젝트의 두 가지 상태

커널 오브젝트의 큰 관심사는 종료 여부다.

종료된 상태 : signaled 상태

종료되지 않은 상태 : non-signaled 상태

boolean형 변수로 표현됨



운영체제가 프로세스나 쓰레드가 종료되면 해당 커널 오브젝트를 signaled 상태로 변경함.

따라서 커널 오브젝트가 종료된 상태인지 종료가 안된 상태인지 확인하는 함수인 WaitForSingleObject 함수와

WaitForMultipleObjects 함수가 있음.

이벤트 발생에 의해서 signaled상태가 반환되면 해당 커널 오브젝트를 다시 non-signaled 상태로 되돌려 놓기도 하는데, 이렇게 다시 non-signaled 상태가 되는 커널 오브젝트를 'auto-reset 모드' 커널 오브젝트라 하고, 자동으로 non-signaled 상태가 되지 않는 커널 오브젝트를 'manual-reset 모드' 커널 오브젝트라고 함.



# 소켓프로그래밍 20장 - windows에서의 쓰레드 동기화

윈도우 운영체제의 연산방식 - 이중모드 연산

- 유저모드 : 응용 프로그램이 실행되는 기본모드로, 물리적인 영역으로의 접근이 허용되지 않고, 접근 가능한 메모리 영역에도 제한이 있음 (응용 프로그램 실행모드)
- 커널모드 : 운영체제가 실행될 때의 모드로, 메모리뿐 아니라, 하드웨어의 접근에도 제한이 없음(운영체제 실행모드)

두 가지 모드를 나눈 이유 : 안정성

### 유저모드 동기화

장점 : 빠름

단점 : 운영체제를 거치지 않으므로 기능이 제한적



### 커널모드 동기화

장점 : 유저모드 동기화에 비해 제공되는 기능 많음

Dead-lock에 걸리지 않도록 타임아웃이 지정이 가능함.

다른 프로세스 사이에 동기화 가능



Event, Semaphore, Mutex



### Mutex(Mutual Exclusion) 오브젝트 기반 동기화

Mutex 오브젝트는 소유자가 없는 경우에 signaled 상태가 된다.



Mutex 생성 : CreateMutex()

Mutex 소멸 : CloseHandle() -> Mutex도 커널 오브젝트임

Mutex 획득 : WaitForSingleObject()

Mutex 반납 : ReleaseMutex()